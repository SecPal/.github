# SPDX-FileCopyrightText: 2025 SecPal
# SPDX-License-Identifier: CC0-1.0

# Reusable Dependabot Auto-Merge Workflow
# Automatically merges Dependabot PRs based on configurable phase/policy
#
# Usage in other repositories:
#   jobs:
#     auto-merge:
#       uses: SecPal/.github/.github/workflows/reusable-dependabot-auto-merge.yml@main
#       with:
#         phase: "1"  # Optional: 1 (PATCH only), 2 (PATCH+MINOR), 3 (all)
#
# Strategy:
#   Phase 1 (default): PATCH updates auto-merge ‚úÖ, MINOR/MAJOR require review
#   Phase 2: PATCH + MINOR auto-merge ‚úÖ, MAJOR requires review
#   Phase 3: All updates auto-merge ‚úÖ (use with caution!)
#
# Rollback strategy: Git revert the auto-merged commit if issues occur

name: Reusable Dependabot Auto-Merge

on:
  workflow_call:
    inputs:
      phase:
        description: "Auto-merge phase: 1 (PATCH only), 2 (PATCH+MINOR), 3 (all)"
        required: false
        default: "1"
        type: string
      merge-method:
        description: "Merge method: merge, squash, or rebase"
        required: false
        default: "squash"
        type: string

permissions:
  contents: write
  pull-requests: write

jobs:
  # Determine if this PR is eligible for auto-merge
  check-eligibility:
    name: Check Auto-Merge Eligibility
    runs-on: ubuntu-latest
    if: github.actor == 'dependabot[bot]'
    outputs:
      should-auto-merge: ${{ steps.check.outputs.should-auto-merge }}
      update-type: ${{ steps.check.outputs.update-type }}
    steps:
      - name: Check PR metadata
        id: check
        env:
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_LABELS: ${{ toJSON(github.event.pull_request.labels.*.name) }}
          PHASE: ${{ inputs.phase }}
        run: |
          echo "PR Title: ${PR_TITLE}"
          echo "PR Labels: ${PR_LABELS}"
          echo "Auto-merge Phase: ${PHASE}"

          # Check if PR has 'dependencies' label (required for Dependabot PRs)
          if ! echo "${PR_LABELS}" | grep -q "dependencies"; then
            echo "should-auto-merge=false" >> "${GITHUB_OUTPUT}"
            echo "update-type=not-dependabot" >> "${GITHUB_OUTPUT}"
            echo "‚ùå Not eligible: Missing dependencies label"
            exit 0
          fi

          # Extract version numbers from Dependabot PR title
          # Common formats:
          #   "Bump package from 1.2.3 to 1.2.4"
          #   "Update dependency from 1.2.3 to 1.2.4"
          #   "chore(deps): bump package from 1.2.3 to 1.2.4"
          #   "Bump action from 5 to 6" (GitHub Actions often use single-digit versions)
          #
          # Note: Pre-release versions (1.2.3-beta) and build metadata (1.2.3+build)
          # are NOT supported. Such PRs will fall back to 'unparseable' status and
          # require manual review, which is the safer approach for non-stable versions.

          # Extract "from X[.Y[.Z]] to A[.B[.C]]" pattern (flexible version format)
          if [[ "${PR_TITLE}" =~ from[[:space:]]+([0-9]+)(\.([0-9]+))?(\.([0-9]+))?[[:space:]]+to[[:space:]]+([0-9]+)(\.([0-9]+))?(\.([0-9]+))? ]]; then
            OLD_MAJOR="${BASH_REMATCH[1]}"
            OLD_MINOR="${BASH_REMATCH[3]:-0}"  # Default to 0 if not present
            OLD_PATCH="${BASH_REMATCH[5]:-0}"  # Default to 0 if not present
            NEW_MAJOR="${BASH_REMATCH[6]}"
            NEW_MINOR="${BASH_REMATCH[8]:-0}"  # Default to 0 if not present
            NEW_PATCH="${BASH_REMATCH[10]:-0}" # Default to 0 if not present

            echo "Old version: ${OLD_MAJOR}.${OLD_MINOR}.${OLD_PATCH}"
            echo "New version: ${NEW_MAJOR}.${NEW_MINOR}.${NEW_PATCH}"

            # Determine update type based on semver rules
            if [[ "${NEW_MAJOR}" != "${OLD_MAJOR}" ]]; then
              echo "update-type=major" >> "${GITHUB_OUTPUT}"

              # Phase 3: Auto-merge all (including MAJOR)
              if [[ "${PHASE}" == "3" ]]; then
                echo "should-auto-merge=true" >> "${GITHUB_OUTPUT}"
                echo "‚úÖ Eligible for auto-merge (Phase 3): MAJOR update (${OLD_MAJOR}.x.x ‚Üí ${NEW_MAJOR}.x.x)"
              else
                echo "should-auto-merge=false" >> "${GITHUB_OUTPUT}"
                echo "‚ùå Not eligible: MAJOR update (${OLD_MAJOR}.x.x ‚Üí ${NEW_MAJOR}.x.x) requires manual review (Phase ${PHASE})"
              fi

            elif [[ "${NEW_MINOR}" != "${OLD_MINOR}" ]]; then
              echo "update-type=minor" >> "${GITHUB_OUTPUT}"

              # Phase 2+: Auto-merge MINOR updates
              if [[ "${PHASE}" == "2" || "${PHASE}" == "3" ]]; then
                echo "should-auto-merge=true" >> "${GITHUB_OUTPUT}"
                echo "‚úÖ Eligible for auto-merge (Phase ${PHASE}): MINOR update (${OLD_MAJOR}.${OLD_MINOR}.x ‚Üí ${NEW_MAJOR}.${NEW_MINOR}.x)"
              else
                echo "should-auto-merge=false" >> "${GITHUB_OUTPUT}"
                echo "‚ùå Not eligible: MINOR update (${OLD_MAJOR}.${OLD_MINOR}.x ‚Üí ${NEW_MAJOR}.${NEW_MINOR}.x) requires manual review (Phase ${PHASE})"
              fi

            elif [[ "${NEW_PATCH}" != "${OLD_PATCH}" ]]; then
              echo "update-type=patch" >> "${GITHUB_OUTPUT}"

              # All phases: Auto-merge PATCH updates
              echo "should-auto-merge=true" >> "${GITHUB_OUTPUT}"
              echo "‚úÖ Eligible for auto-merge (Phase ${PHASE}): PATCH update (${OLD_MAJOR}.${OLD_MINOR}.${OLD_PATCH} ‚Üí ${NEW_MAJOR}.${NEW_MINOR}.${NEW_PATCH})"

            else
              echo "should-auto-merge=false" >> "${GITHUB_OUTPUT}"
              echo "update-type=no-change" >> "${GITHUB_OUTPUT}"
              echo "‚ùå Not eligible: Version unchanged"
            fi
          else
            echo "should-auto-merge=false" >> "${GITHUB_OUTPUT}"
            echo "update-type=unparseable" >> "${GITHUB_OUTPUT}"
            echo "‚ùå Not eligible: Could not parse version numbers from PR title"
            echo "    Title format expected: 'Bump X from 1.2.3 to 1.2.4'"
          fi

  # Enable auto-merge for eligible PRs
  auto-merge:
    name: Enable Auto-Merge
    runs-on: ubuntu-latest
    needs: check-eligibility
    if: needs.check-eligibility.outputs.should-auto-merge == 'true'
    steps:
      - name: Wait for CI checks
        uses: lewagon/wait-on-check-action@v1.4.1
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          wait-interval: 10
          running-workflow-name: "Enable Auto-Merge"
          allowed-conclusions: success,skipped,neutral
        continue-on-error: true

      - name: Enable auto-merge
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_URL: ${{ github.event.pull_request.html_url }}
          MERGE_METHOD: ${{ inputs.merge-method }}
        run: |
          echo "ü§ñ Enabling auto-merge..."
          echo "PR: ${PR_URL}"
          echo "Update type: ${{ needs.check-eligibility.outputs.update-type }}"
          echo "Merge method: ${MERGE_METHOD}"
          echo "Phase: ${{ inputs.phase }}"

          # Enable auto-merge with configured merge strategy
          case "${MERGE_METHOD}" in
            squash)
              gh pr merge --auto --squash "${PR_URL}"
              ;;
            rebase)
              gh pr merge --auto --rebase "${PR_URL}"
              ;;
            merge)
              gh pr merge --auto --merge "${PR_URL}"
              ;;
            *)
              echo "‚ùå Invalid merge method: ${MERGE_METHOD}"
              exit 1
              ;;
          esac

          echo "‚úÖ Auto-merge enabled! PR will merge when all checks pass."

      - name: Add comment
        uses: actions/github-script@v8
        with:
          script: |
            const phase = '${{ inputs.phase }}';
            const updateType = '${{ needs.check-eligibility.outputs.update-type }}';
            const mergeMethod = '${{ inputs.merge-method }}';

            let policyText = '';
            if (phase === '1') {
              policyText = '- ‚úÖ PATCH updates: Auto-merge\n- üîç MINOR updates: Manual review\n- ‚ö†Ô∏è MAJOR updates: Manual review';
            } else if (phase === '2') {
              policyText = '- ‚úÖ PATCH updates: Auto-merge\n- ‚úÖ MINOR updates: Auto-merge\n- ‚ö†Ô∏è MAJOR updates: Manual review';
            } else if (phase === '3') {
              policyText = '- ‚úÖ PATCH updates: Auto-merge\n- ‚úÖ MINOR updates: Auto-merge\n- ‚úÖ MAJOR updates: Auto-merge';
            }

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `ü§ñ **Auto-merge enabled** for this ${updateType} update.\n\n` +
                    `This PR will automatically merge when all required checks pass.\n\n` +
                    `**Configuration:**\n` +
                    `- Update type: \`${updateType}\`\n` +
                    `- Merge strategy: \`${mergeMethod}\`\n` +
                    `- Policy phase: \`${phase}\`\n\n` +
                    `**Current auto-merge policy (Phase ${phase}):**\n${policyText}\n\n` +
                    `**Rollback:** If issues occur, use \`git revert\` on the merge commit.\n\n` +
                    `_Automated by Dependabot Auto-Merge Workflow_`
            })

  # Skip auto-merge for non-eligible PRs (informational)
  skip-auto-merge:
    name: Skip Auto-Merge
    runs-on: ubuntu-latest
    needs: check-eligibility
    if: needs.check-eligibility.outputs.should-auto-merge != 'true' && github.actor == 'dependabot[bot]'
    steps:
      - name: Add comment for manual review
        uses: actions/github-script@v8
        with:
          script: |
            const updateType = '${{ needs.check-eligibility.outputs.update-type }}';
            const phase = '${{ inputs.phase }}';
            let emoji = 'üîç';
            let title = 'Manual review required';
            let reason = 'This update requires manual review.';

            if (updateType === 'major') {
              emoji = '‚ö†Ô∏è';
              title = 'MAJOR version update detected';
              reason = 'This is a **MAJOR** version update which may contain breaking changes.\n\n' +
                       '**Action required:**\n' +
                       '1. Review the changelog for breaking changes\n' +
                       '2. Update code if necessary\n' +
                       '3. Verify all tests pass\n' +
                       '4. Merge manually after verification';
              if (phase === '3') {
                reason += '\n\n‚ö†Ô∏è **Note:** Your policy is set to Phase 3 but this PR was not auto-merged. Check the logs for details.';
              }
            } else if (updateType === 'minor') {
              emoji = 'üîç';
              title = 'MINOR version update detected';
              reason = 'This is a **MINOR** version update which may contain new features.\n\n' +
                       '**Action required:**\n' +
                       '1. Review the changelog for new features\n' +
                       '2. Consider if new features should be utilized\n' +
                       '3. Verify all tests pass\n' +
                       '4. Merge manually after verification';
              if (phase === '1') {
                reason += '\n\n**Note:** In Phase 2, MINOR updates will be auto-merged.';
              } else if (phase === '2' || phase === '3') {
                reason += '\n\n‚ö†Ô∏è **Note:** Your policy is set to Phase ' + phase + ' but this PR was not auto-merged. Check the logs for details.';
              }
            } else if (updateType === 'unparseable') {
              emoji = '‚ùì';
              title = 'Could not determine update type';
              reason = 'The PR title format could not be parsed.\n\n' +
                       'Expected format: `Bump package from X.Y.Z to A.B.C`\n\n' +
                       'Please review manually.';
            } else {
              emoji = 'üîç';
              reason = `Update type: \`${updateType}\`\n\nPlease review and merge manually.`;
            }

            let policyText = '';
            if (phase === '1') {
              policyText = '- ‚úÖ PATCH updates: Auto-merge\n- üîç MINOR updates: Manual review\n- ‚ö†Ô∏è MAJOR updates: Manual review';
            } else if (phase === '2') {
              policyText = '- ‚úÖ PATCH updates: Auto-merge\n- ‚úÖ MINOR updates: Auto-merge\n- ‚ö†Ô∏è MAJOR updates: Manual review';
            } else if (phase === '3') {
              policyText = '- ‚úÖ PATCH updates: Auto-merge\n- ‚úÖ MINOR updates: Auto-merge\n- ‚úÖ MAJOR updates: Auto-merge';
            }

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `${emoji} **${title}**\n\n` +
                    `${reason}\n\n` +
                    `---\n` +
                    `**Current auto-merge policy (Phase ${phase}):**\n${policyText}\n\n` +
                    `_See policy: \`SecPal/.github/.github/workflows/reusable-dependabot-auto-merge.yml\`_`
            })
