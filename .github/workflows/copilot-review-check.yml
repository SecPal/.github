# SPDX-FileCopyrightText: 2025 SecPal
# SPDX-License-Identifier: AGPL-3.0-or-later

name: Copilot Review Check

on:
  pull_request:
    types: [opened, synchronize, reopened]
  pull_request_review:
    types: [submitted]

# Prevent duplicate runs
concurrency:
  group: copilot-review-check-${{ github.event.pull_request.number || github.event.issue.number }}
  cancel-in-progress: true

jobs:
  check-copilot-review:
    name: Verify Copilot Review
    runs-on: ubuntu-latest
    permissions:
      pull-requests: read
    steps:
      - name: Check for Copilot review after last push
        uses: actions/github-script@v7
        with:
          script: |
            const COPILOT_REVIEWER_LOGIN_PREFIX = 'copilot-pull-request-reviewer';
            const MAX_WAIT_MS = 90000; // 90 seconds
            const POLL_INTERVAL_MS = 5000; // 5 seconds

            const pr = context.payload.pull_request;
            const prNumber = pr ? pr.number : context.issue.number;
            const eventAction = context.payload.action;

            core.info(`Event: ${context.eventName}, Action: ${eventAction}`);

            // Main check logic
            async function doCheck() {
              const commits = await github.paginate(github.rest.pulls.listCommits, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });

              if (commits.length === 0) {
                throw new Error('No commits found in PR');
              }

              const lastCommit = commits[commits.length - 1];
              const lastPushTime = new Date(lastCommit.commit.committer.date);
              core.info(`Last commit at: ${lastPushTime.toISOString()}`);

              const { data: reviews } = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });

              const copilotReviews = reviews.filter(review =>
                review.user.login.startsWith(COPILOT_REVIEWER_LOGIN_PREFIX) &&
                review.user.type === 'Bot'
              );

              if (copilotReviews.length === 0) {
                throw new Error('No Copilot review found. Please request a Copilot review.');
              }

              const reviewsAfterCommit = copilotReviews.filter(review => {
                const reviewTime = new Date(review.submitted_at);
                return reviewTime >= lastPushTime;
              });

              if (reviewsAfterCommit.length === 0) {
                const lastReview = copilotReviews[copilotReviews.length - 1];
                const lastReviewTime = new Date(lastReview.submitted_at);
                throw new Error(
                  `Last Copilot review was before the latest commit. ` +
                  `Last review: ${lastReviewTime.toISOString()}, ` +
                  `Last commit: ${lastPushTime.toISOString()}. ` +
                  `Please request a new Copilot review.`
                );
              }

              const latestReview = reviewsAfterCommit[reviewsAfterCommit.length - 1];
              core.info(`✓ Found Copilot review after last commit at: ${latestReview.submitted_at}`);
            }

            // For 'opened' event: retry with timeout
            if (eventAction === 'opened') {
              core.info('PR opened - will wait up to 90 seconds for Copilot review...');
              const startTime = Date.now();
              let lastError;

              while (Date.now() - startTime < MAX_WAIT_MS) {
                try {
                  await doCheck();
                  core.info('✅ Check passed!');
                  process.exit(0);
                } catch (error) {
                  lastError = error;
                  const elapsed = Math.round((Date.now() - startTime) / 1000);
                  core.info(`No review yet (${elapsed}s elapsed). Waiting...`);
                  await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL_MS));
                }
              }

              core.setFailed(`Timeout after 90s: ${lastError.message}`);
            } else {
              // For other events: immediate check
              try {
                await doCheck();
              } catch (error) {
                core.setFailed(error.message);
              }
            }
